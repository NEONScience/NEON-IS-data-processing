##############################################################################################
#' @title Wrapper for computing individual measurement uncertainty for NEON L0' data

#' @author 
#' Cove Sturtevant \email{csturtevant@battelleecology.org}

#' @description 
#' Wrapper function. Compute individual measurement uncertainty for calibrated data at native
#' frequency (NEON L0' data).   

#' @param data Data frame of L0 data. Must include POSIXct time variable readout_time.  
#' @param ParaUcrt A data frame of the variables for which individual measurement uncertainty is
#' to be calculated. Columns include:\cr
#' \code{var} Character. The variable in data for which to compute uncertainty \cr
#' \code{typeFdas} A single character indicating the type of measurement made by NEON's field 
#' data acquisision system (GRAPE). Acceptable values are "R" for resistance measurements, "V" 
#' for voltage measurements, or NA (no quotes) for measurements in which FDAS uncertainty does
#' not apply (e.g. digital L0 output) \cr
#' \code{FuncUcrt} A character string indicating the individual measurement (calibration) uncertainty 
#' function within the NEONprocIS.cal package that should be used. Note that this does not include 
#' FDAS uncertainty. For most NEON data products, this will be "def.ucrt.meas.cnst". Note that any 
#' alternative function must accept arguments "data", "infoCal", and "log", even if they are unused 
#' in the function, and must return a data frame, one column of which is labeled "ucrtMeas" which 
#' corresponds to the individual measurement uncertainty for the variable. Input "data" to the function
#' is an array of the data for the applicable term. Input "infoCal" is a data frame of calibration 
#' information (including uncertainty) as returned from NEONprocIS.cal::def.read.cal.xml. 
#' If no calibration files are associated with the term, infoCal would be passed in to the function as 
#' NULL. Input "log" is a logger object as generated by NEONprocIS.base::def.log.init and used in 
#' this script to generate hierarchical logging.\cr
#' @param ucrtCoefFdas A data frame of FDAS uncertainty coefficients, as read by 
#' NEONprocIS.cal::def.read.ucrt.coef.fdas. Columns include:\cr
#' \code{Name} Character. Name of the coefficient.\cr
#' \code{Value} Character. Value of the coefficient.\cr
#' \code{.attrs} Character. Relevant attribute (i.e. units)\cr
#' Defaults to NULL, in which case no variables in ParaUcrt may indicate that FDAS uncertainty 
#' applies.
#' @param calSlct A named list of data frames, list element corresponding to the variables in
#' ParaUcrt. The data frame in each list element holds information about the calibration files and 
#' time periods that apply to the variable, as returned from NEONprocIS.cal::def.cal.slct. 
#' See documentation for that function. Assign NULL to list elements (variables) for which calibration
#' information is not applicable (i.e. a function other than def.ucrt.meas.cnst is used to compute its
#' uncertainty).
#' @param DirCal Character string. Relative or absolute path (minus file name) to the main calibration
#' directory. Nested within this directory are directories for each variable in calSlct, each holding
#' calibration files for that variable. Defaults to "./"
#' @param mappNameVar A data frame with in/out variable name mapping as produced by 
#' NEONprocIS.base::def.var.mapp.in.out. See documentation for that function. If input (default is NULL),
#' output variable names will be appended as prefixes to the column names in each output data frame. 
#' @param log A logger object as produced by NEONprocIS.base::def.log.init to produce structured log
#' output. Defaults to NULL, in which the logger will be created and used within the function.

#' @return A named list, each element corresponding to those in ParaUcrt$var and holding a data
#' frame of uncertainty data. Note that each row in each data frame corresponds to the times in 
#' data$readout_time, but the variable readout_time is not included in the output. One column
#' in each data frame is labeled ucrtComb, corresponding to the combined measurement uncertainty
#' of the individual measurements and FDAS (if applicable). If FDAS uncertainty does not apply, 
#' ucrtComb is simply a copy of ucrtMeas. \cr

#' @references Currently none

#' @keywords Currently none

#' @examples Currently none

#' @seealso \link[NEONprocIS.cal]{def.cal.slct}
#' @seealso \link[NEONprocIS.cal]{def.read.cal.xml}
#' @seealso \link[NEONprocIS.base]{def.var.mapp.in.out}

#' @export

# changelog and author contributions / copyrights
#   Cove Sturtevant (2020-02-13)
#     original creation
#   Mija Choi (2020-08-14)
#     modified uncertainty function to use, FuncUcrtIdx, by replacing FuncUcrt$ with ParaUcrt$
##############################################################################################
wrap.ucrt.dp0p <- function(data,
                           ParaUcrt,
                           ucrtCoefFdas=NULL,
                           calSlct,
                           DirCal="./",
                           mappNameVar=NULL,
                           log=NULL){
  # initialize logging if necessary
  if (base::is.null(log)) {
    log <- NEONprocIS.base::def.log.init()
  }
  
  # Initialize
  ucrtData <- base::vector(mode = "list", length = base::length(ParaUcrt$var))
  base::names(ucrtData) <- ParaUcrt$var
  timeMeas <- data$readout_time
  
  # Loop through the variables
  for(idxVar in ParaUcrt$var){
    
    # Determine the uncertainty function to use
    FuncUcrtIdx <- base::get(ParaUcrt$FuncUcrt[ParaUcrt$var == idxVar], base::asNamespace("NEONprocIS.cal"))
    
    # Get output variable name
    nameVarUcrtOut <- mappNameVar$nameVarOut[mappNameVar$nameVarIn==idxVar]
    
    # Determine whether FDAS uncertainty applies to this variable, and what function
    FuncFdas <- NULL
    typeFdas <- ParaUcrt$typeFdas[ParaUcrt$var == idxVar][1]
    if(!base::is.na(typeFdas)){
      FuncFdas <- base::switch(typeFdas,
                               R=NEONprocIS.cal::def.ucrt.fdas.rstc,
                               V=NEONprocIS.cal::def.ucrt.fdas.volt)
    } 
    
    # Run through each selected calibration and apply the uncertainty function for the applicable time period
    calSlctIdx <- calSlct[[idxVar]]
    for(idxRow in base::seq_len(base::nrow(calSlctIdx))){
      
      # What points in the output correspond to this row?
      setCal <- timeMeas >= calSlctIdx$timeBgn[idxRow] & timeMeas < calSlctIdx$timeEnd[idxRow]
      
      # If a calibration file is available for this period, open it and get calibration information
      if(!base::is.na(calSlctIdx$file[idxRow])){
        fileCal <- base::paste0(DirCal,'/',idxVar,'/',calSlctIdx$file[idxRow])
        infoCal <- NEONprocIS.cal::def.read.cal.xml(NameFile=fileCal,Vrbs=TRUE)
      } else {
        infoCal <- NULL
      }
      
      # Pass the calibration information and the data to the uncertainty function
      ucrtMeas <- base::do.call(FuncUcrtIdx,args=base::list(data=data[setCal,idxVar],infoCal=infoCal,log=log))
      
      
      # Compute FDAS uncertainty, if applicable
      if(!base::is.na(typeFdas)){
        
        # Get applicable FDAS uncertainty coefs depending on the type of FDAS that applies
        setFdasCoef <- base::switch(typeFdas,
                                    R=base::grepl(pattern='U_CVAL[RF]',ucrtCoefFdas$Name),
                                    V=base::grepl(pattern='U_CVAL[VG]',ucrtCoefFdas$Name),
                                    base::logical(0))
        
        # Add the applicable FDAS uncertainty coefs to those from the cal file
        infoCal$ucrt <- base::rbind(infoCal$ucrt,ucrtCoefFdas[setFdasCoef,],stringsAsFactors=FALSE)
        
        # Get applicable FDAS uncertainty
        ucrtFdas <- base::do.call(FuncFdas,args=base::list(data=data[setCal,idxVar],infoCal=infoCal,log=log))
        
        # Combine with ucrtMeas
        if(base::nrow(ucrtMeas) != base::nrow(ucrtFdas)){
          log$error('Number of rows returned from measurement uncertainty function do not equal that from FDAS uncertainty function. Something is wrong in the code.')
          stop()
        }
        ucrtMeas <- base::cbind(ucrtMeas,ucrtFdas)
      }
      
      # Put in overall output for this variable
      if(idxRow == 1){
        # Initialize the output with our known columns names
        ucrtDataIdx <-
          base::as.data.frame(
            base::matrix(
              data = NA,
              nrow = base::length(timeMeas),
              ncol = base::ncol(ucrtMeas),
              dimnames = base::list(NULL, base::names(ucrtMeas))
            ),
            stringsAsFactors = FALSE
          )
      }
      # Place this round of uncertainty data in the output
      ucrtDataIdx[setCal,] <- ucrtMeas
      
    } # End loop around selected calibrations
    
    # Compute combined uncertainty for this variable
    if(!base::is.na(typeFdas)){
      # Compute combined uncertainty (ucrtMeas and ucrtFdas)
      ucrtDataIdx <- base::cbind(ucrtDataIdx,NEONprocIS.cal::def.ucrt.comb(ucrt=base::subset(ucrtDataIdx,select=c('ucrtMeas','ucrtFdas')),log=log))
    } else {
      # Combined uncertainty is simply ucrtMeas
      ucrtDataIdx <- base::cbind(ucrtDataIdx,NEONprocIS.cal::def.ucrt.comb(ucrt=base::subset(ucrtDataIdx,select=c('ucrtMeas')),log=log))
    }
    
    # Compute expanded uncertainty
    ucrtDataIdx <- base::cbind(ucrtDataIdx,NEONprocIS.cal::def.ucrt.expn(ucrtComb=ucrtDataIdx[['ucrtComb']],log=log))
    
    # Append the output variable name as a prefix to each column
    if(!base::is.null(nameVarUcrtOut)){
      base::names(ucrtDataIdx) <- base::paste0(nameVarUcrtOut,'_',base::names(ucrtDataIdx))
    }
    
    # Place uncertainty for this variable in overall output
    ucrtData[[idxVar]] <- ucrtDataIdx
    
  } # End loop around variables for which to compute individual combined measurement uncertainty 
  
  return(ucrtData)
  
}
