##############################################################################################
#' @title Wrapper for insufficient data calculations

#' @author
#' Bobby Hensley \email{hensley@battelleecology.org}
#' 
#' @description Wrapper function. Determines the number of available measurements within an
#' averaging period, and whether an insufficient data quality flag should be applied.
#' This insufficient data quality flag is then used to determine whether the final quality
#' flag should be applied.  It assumes that measurements that have failed individual
#' plausibility and sensor-specific tests have been removed and the number of remaining 
#' measurements available for averaging is the only factor determining the final data quality.    
#'
#' @param DirIn Character value. The base file path to the averaged stats and quality metrics.
#' 
#' @param InssuffParam Data table of parameters generated by flow script.
#' 
#' @param DirOut Character value. The base file path for the output data. 
#' 
#' @param SchmStats (optional), A json-formatted character string containing the schema for the output averaged stats parquet.
#' Should be the same as the input. 
#' 
#' @param SchmQMs (optional), A json-formatted character string containing the schema for the output quality metrics parquet 
#' with insufficient data quality flag added. 
#' 
#' @param DirSubCopy (optional) Character vector. The names of additional subfolders at 
#' the same level as the location folder in the input path that are to be copied with a symbolic link to the 
#' output path (i.e. not combined but carried through as-is).
#' 
#' @param log A logger object as produced by NEONprocIS.base::def.log.init to produce structured log
#' output. Defaults to NULL, in which the logger will be created and used within the function. See NEONprocIS.base::def.log.init
#' for more details.
#' 
#' @return Averaged stats file and quality metric file in daily parquets.
#' 
#' @references
#' License: (example) GNU AFFERO GENERAL PUBLIC LICENSE Version 3, 19 November 2007
#' 
#' @keywords Currently none
#' 
#' @examples
#' # Not run
# DirIn<-"~/pfs/nitrate_null_gap_ucrt/2025/06/24/nitrate_CRAM103100/sunav2/CFGLOC110733"
# insuffParamEx<-read.csv("~/pfs/insuffParamExample.csv")
# DirOutBase<-"~/pfs/out" 
# SchmStats<-base::paste0(base::readLines('~/pfs/sunav2_avro_schemas/sunav2_stats.avsc'),collapse='')
# SchmQMs<-base::paste0(base::readLines('~/pfs/sunav2_avro_schemas/sunav2_quality_metrics.avsc'),collapse='')
# log <- NEONprocIS.base::def.log.init(Lvl = "debug")
#'
#'                                                                                                                                                                                          
#' @changelog
#' Bobby Hensley (2025-10-31)
#' Initial creation.
#' 
#' Bobby Hensley (2025-12-18)
#' Updated so that finalQF is solely determined by insufficientDataQF.
#' Nora Catolico (2026-02-06)
#' Updated for data frame input of multiple variables. 
##############################################################################################
wrap.qf.insuff.data <- function(DirIn,
                                insuffParam,
                                DirOutBase,
                                SchmStats=NULL,
                                SchmQMs=NULL,
                                DirSubCopy=NULL,
                                log=NULL
){
  
  #' Start logging if not already.
  if(base::is.null(log)){
    log <- NEONprocIS.base::def.log.init()
  } 
  
  InfoDirIn <- NEONprocIS.base::def.dir.splt.pach.time(DirIn)
  DirInStats <- paste0(DirIn,"/stats")
  DirInQMs <- paste0(DirIn,"/quality_metrics")
  DirOut <- base::paste0(DirOutBase,InfoDirIn$dirRepo)
  DirOutStats <- base::paste0(DirOut,"/stats")
  base::dir.create(DirOutStats,recursive=TRUE)
  DirOutQMs <- base::paste0(DirOut,"/quality_metrics")
  base::dir.create(DirOutQMs,recursive=TRUE)
  
  # Copy with a symbolic link the desired subfolders 
  if(base::length(DirSubCopy) > 0){
    NEONprocIS.base::def.dir.copy.symb(DirSrc=base::paste0(DirIn,'/',DirSubCopy),
                                       DirDest=DirOut,
                                       LnkSubObj=TRUE,
                                       log=log)
  }
  
  #take stock of available files
  statsFileNames<-base::list.files(DirInStats,full.names=FALSE)
  qmFileNames<-base::list.files(DirInQMs,full.names=FALSE)
  
  #loop through unique insuffParam values
  paramGroups<-unique(insuffParam$InfoSet)
  numGroups<-length(paramGroups)
  
  for (groupIdx in 1:numGroups){
    #subset to one group
    paramGroup <- insuffParam[insuffParam$InfoSet == paramGroups[groupIdx],]
    
    #identify averaging index and min points
    wndw <- as.character(paramGroup$value[paramGroup$field == "wndw"])
    minPoints <- as.numeric(paramGroup$value[paramGroup$field == "minPoints"])
    term <- as.character(paramGroup$value[paramGroup$field == "term"])
    
    #' choose appropriate file and read in averaged stats parquet
    statsFile <- statsFileNames[grepl(paste0(wndw, "\\.parquet$"), statsFileNames)]
    if(length(statsFile)==0){
      log$error(base::paste0('Stats file with averaging window ', wndw,' not found in ', DirInStats)) 
      stop()
    }
    statsData<-NEONprocIS.base::def.read.parq(NameFile = base::paste0(DirInStats, '/', statsFile),
                                              log = log)
    log$debug(base::paste0('Successfully read in file: ',statsFile))
    
    #' choose appropriate file and read in averaged quality parquet
    qmFile <- qmFileNames[grepl(paste0(wndw, "\\.parquet$"), qmFileNames)]
    if(length(qmFile)==0){
      log$error(base::paste0('Quality metrics file with averaging window ', wndw,' not found in ', DirInQMs)) 
      stop()
    }
    qmData<-NEONprocIS.base::def.read.parq(NameFile = base::paste0(DirInQMs, '/', qmFile),
                                              log = log)
    log$debug(base::paste0('Successfully read in file: ',qmFile))
    
    
    
    # Return the column name(s) containing term and number of points
    numPointsColumn <- names(statsData)[grepl(term, names(statsData), ignore.case = TRUE) & 
                                   grepl("Num", names(statsData), ignore.case = TRUE)]
    if(length(numPointsColumn)!=1){
      log$error(base::paste0('No column found with name the includes ', term,' and num in', DirInStats)) 
      stop()
    }
    #' If the number of points is NA, set it to 0.
    statsData[is.na(statsData[[numPointsColumn]]), numPointsColumn] <- 0 
    
    #find insufficient data column name if it already exists 
    insuffQFColumn <- names(qmData)[grepl("insuf", names(qmData), ignore.case = TRUE)]
    #search by term if multiple exist
    if(length(insuffQFColumn)>1){
      insuffQFColumn <- names(qmData)[grepl(term, names(qmData), ignore.case = TRUE) & 
                                        grepl("insuf", names(qmData), ignore.case = TRUE)]
    }
    #add it in if it doesn't exist
    if(length(insuffQFColumn)==0){
      insuffQFColumn <- "insufficientDataQF"
    }
    #' If the number of points is greater than or equal to the minimum required, 
    #' revert the insufficient data quality flag (default is to apply it).
    qmData[[insuffQFColumn]]<-1
    qmData[statsData[[numPointsColumn]] >= minPoints, insuffQFColumn] <- 0 
      
      
    #find final QF column name if it already exists 
    finalQFcolumn <- names(qmData)[grepl("final", names(qmData), ignore.case = TRUE)]
    #search by term if multiple exist
    if(length(finalQFcolumn)>1){
      finalQFcolumn <- names(qmData)[grepl(term, names(qmData), ignore.case = TRUE) & 
                                        grepl("final", names(qmData), ignore.case = TRUE)]
    }
    #add it in if it doesn't exist
    if(length(finalQFcolumn)==0){
      finalQFcolumn <- "finalQF"
    }
    
    #' If insufficient data QF is applied, apply final QF.
    qmData[[finalQFcolumn]] <- ifelse(qmData[[insuffQFColumn]] == 1, 1, 0) 
    
    #' Write out stats file.  
    rptOutStats <- try(NEONprocIS.base::def.wrte.parq(data = statsData,
                                                      NameFile = base::paste0(DirOutStats,'/',statsFile),
                                                      Schm = SchmStats),silent=TRUE)
    if(class(rptOutStats)[1] == 'try-error'){
      log$error(base::paste0('Cannot write updated stats to ',base::paste0(DirOutStats,'/',statsFile),'. ',attr(rptOutStats, "condition")))
      stop()
    } else {
      log$info(base::paste0('Updated stats written successfully in ', base::paste0(DirOutStats,'/',statsFile)))
    }
    
    #' Write out QMs file.  
    rptOutQMs <- try(NEONprocIS.base::def.wrte.parq(data = qmData,
                                                    NameFile = base::paste0(DirOutQMs,'/',qmFile),
                                                    Schm = SchmQMs),silent=TRUE)
    if(class(rptOutQMs)[1] == 'try-error'){
      log$error(base::paste0('Cannot write updated QMs to ',base::paste0(DirOutQMs,'/',qmFile),'. ',attr(rptOutQMs, "condition")))
      stop()
    } else {
      log$info(base::paste0('Updated QMs written successfully in ', base::paste0(DirOutQMs,'/',qmFile)))
    }
    
  }
  
}



